*假设你正在爬楼梯。需要 n 阶你才能到达楼顶。*

*每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？*

这道题的思路非常简单，这也是最常见的递归的题目，很容易得到

f(n) = f(n - 1) + f(n - 2)

这其实就是斐波那契数列，那么其实就是编程实现得到斐波那契数列任意项的程序。

    class Solution:
    def climbStairs(self, n: int) -> int:
        if n < 0:
            return o
        elif n == 0:
            return 1
        else:
            return self.climbStairs(n - 1) + self.climbStairs(n - 2)

运行代码几个基础实例运行是没有问题的， 但是在提交后出现运行超时的问题，所以需要换一种方法来实现这个功能，看了题解后改成：

    class Solution:
    def climbStairs(self, n: int) -> int:
        p = [0, 0, 1]
        for _ in range(1, n+1):
            p[0] = p[1]
            p[1] = p[2]
            p[2] = p[1] + p[0]
        return p[2]

这个解法其实思路和递归第一版是一样的，但是可能存在问题是，第一版的递归中程序在不断地创建新的子程序，如果n非常大的话，可能存在非常大的空间开销，但是第二版的方法对于空间开销肯定是比较小的。看了题解以后知道居然还有这种思想叫’滚动数组思想‘，但是和我的理解基本相同就是可以有效降低空间复杂度。